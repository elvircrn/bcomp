/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(COCO_PARSER_H__)
#define COCO_PARSER_H__

using namespace std;
#include <sstream>
#include <wchar.h>
typedef  wchar_t Name[500];
#include <string>
#include <iostream>


#include "Scanner.h"



class Errors {
public:
	int count;			// number of errors detected

	Errors();
	void SynErr(int line, int col, int n);
	void Error(int line, int col, const wchar_t *s);
	void Warning(int line, int col, const wchar_t *s);
	void Warning(const wchar_t *s);
	void Exception(const wchar_t *s);

}; // Errors

class Parser {
private:
	enum {
		_EOF=0,
		_identifier=1,
		_gotolabel=2,
		_number=3,
		_onumber=4,
		_string=5,
		_char=6
	};
	int maxT;

	Token *dummyToken;
	int errDist;
	int minErrDist;

	void SynErr(int n);
	void Get();
	void Expect(int n);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);

public:
	Scanner *scanner;
	Errors  *errors;

	Token *t;			// last recognized token
	Token *la;			// lookahead token

std::wstring ParseList;
int scopepos;
std::wstringstream _asmOutput;
std::wstringstream _ast;

  int childrenCount(int position);

  std::wstring AST() {
	  return _ast.str();
  }

  std::wstring AsmOutput() {
	  return _asmOutput.str();
  }

  bool IsDeclaredLocal(Name name1) {
	  std::wstring name = std::wstring(name1);
	  std::string::size_type found;
	  std::wstring decls[4] = {L"EXTRN", L"LARRDEF", L"LVARDEF", L"FPARAM"};
	  for (int i = 0; i < 4; i++) {
		  found = ParseList.find(L"(" + decls[i] + L" " + name + L" ", scopepos);
		  if (found != std::string::npos)
			  return true;
	  }
	  return false;
  }

  bool IsAuto(Name name1) {
	  std::wstring name = std::wstring(name1);
	  std::string::size_type found;
	  std::wstring decls[3] = {L"LARRDEF", L"LVARDEF", L"FPARAM"};
	  for (int i = 0; i < 3; i++) {
		  found = ParseList.find(L"(" + decls[i] + L" " + name + L" ", scopepos);
		  if (found != std::string::npos)
			  return true;
	  }
	  return false;
  }

  bool IsDeclaredGlobal(Name name1) {
	  std::wstring name = std::wstring(name1);
	  std::string::size_type found;
	  std::wstring decls[4] = {L"GARRDEF", L"GVARDEF", L"FUNCDEF"};
	  for (int i = 0; i < 4; i++) {
		  found = ParseList.find(L"(" + decls[i] + L" " + name + L" ", 0);
		  if (found != std::string::npos)
			  return true;
	  }

	  return false;
  }

  void UndecErr(Name name) {
	  Name msg;
	  wcscpy(msg, L"Undeclared ");
	  wcscat(msg, name);
	  SemErr(msg);
  }

  void AlreadyErr(Name name) {
	  Name msg;
	  wcscpy(msg, L"Already declared ");
	  wcscat(msg, name);
	  SemErr(msg);
  }

  std::wstring GetNodeName(int position) {
	  wstring NodeName;
	  NodeName = L"";
	  if (ParseList[position] != '(')
		  return L"";
	  position++;
	  while (ParseList[position] >= 'A' && ParseList[position] <= 'Z') {
		  NodeName += ParseList[position];
		  position++;
	  }
	  return NodeName;
  }

  std::wstring GetElemName(int position, int elemnum) {
	  wstring ElemName;
	  position = ElemPos(position, elemnum);
	  ElemName = L"";
	  if (position > 0)
		  while (ParseList[position] != ' ' && ParseList[position] != ')') {
			  ElemName += ParseList[position];
			  position++;
		  }
	  return ElemName;
  }

  int ElemPos(int position, int elemnum) {
	  int currel, brlevel;
	  currel = 0;
	  position++;
	  while (ParseList[position] >= 'A' && ParseList[position] <= 'Z')
		  position++;
	  for (;;) {
		  while (ParseList[position] == ' ')
			  position++;
		  currel++;
		  if (currel == elemnum && ParseList[position] != ')')
			  return position;
		  switch (ParseList[position]) {
		  case '(':
			  brlevel = 1;
			  position++;
			  while (brlevel != 0) {
				  while (ParseList[position] != '(' && ParseList[position] != '`' &&
						  ParseList[position] != ')')
					  position++;
				  switch (ParseList[position]) {
				  case '(':
					  brlevel++;
					  position++;
					  break;
				  case ')':
					  brlevel--;
					  position++;
					  break;
				  case '`':
					  do {
						  position++;
					  } while (ParseList[position] != '`');
					  position++;
					  break;
				  }
			  }
			  break;
		  case ')':
			  return -1;
			  break;
		  case '`':
			  do {
				  position++;

			  } while (ParseList[position] != '`');
			  position++;
			  break;
		  default:
			  while (ParseList[position] != '(' && ParseList[position] != ' ' &&
					  ParseList[position] != ')')
				  position++;
		  }
	  }
  }

// TODO: L"VAR", L"INDEX" ili L"PTR"
  bool Assignable(int position);

  void Compile(int position) {
	  wstring nodename, elemname;
	  int par, z, q;
	  nodename = GetNodeName(position);
	  par = 1;
	  if (nodename == L"ADD") {
		  z = ElemPos(position, 1);
		  q = ElemPos(position, 2);
		  Compile(z);
		  if (GetNodeName(q) == L"INT") {
			  _asmOutput << L" ADD EAX," << GetElemName(q, 1) << endl;
		  } else if (GetNodeName(q) == L"VAR") {
			  _asmOutput << L" ADD EAX,[" << GetElemName(q, 1) << "]" << endl;
		  } else {
			  _asmOutput << L" PUSH EAX";
			  Compile(q);
			  _asmOutput << L" POP EBX";
			  _asmOutput << L" ADD EAX,EBX" << endl;
		  }
	  } else if (nodename == L"ADDMOV") {
	  } else if (nodename == L"ADDROF") {
	  } else if (nodename == L"AND") {
	  } else if (nodename == L"ANDMOV") {
	  } else if (nodename == L"ARG") {
	  } else if (nodename == L"ASIZE") {
	  } else if (nodename == L"BLOCK") {
		  while ((z = ElemPos(position, par)) > 0) {
			  Compile(z);
			  par++;
		  }
	  } else if (nodename == L"BREAK") {
	  } else if (nodename == L"B") {
		  while ((z = ElemPos(position, par)) > 0) {
			  Compile(z);
			  par++;
		  }
	  } else if (nodename == L"CHAR") {
	  } else if (nodename == L"CONDEXPR") {
	  } else if (nodename == L"CONTINUE") {
	  } else if (nodename == L"DECLSTAT") {
		  while ((z = ElemPos(position, par)) > 0) {
			  Compile(z);
			  par++;
		  }
	  } else if (nodename == L"DEFAULT") {
	  } else if (nodename == L"DIV") {
	  } else if (nodename == L"DIVMOV") {
	  } else if (nodename == L"EQU") {
	  } else if (nodename == L"EXTRN") {
	  } else if (nodename == L"FHEADER") {
	  } else if (nodename == L"FPARAM") {
	  } else if (nodename == L"FUNCCALL") {
		  std::wstring funcName = GetElemName(ElemPos(position, 1), 1);

      std::wcout << L"Args: \n"; 
      for (size_t i = 0; i < 10; i++) {
        std::wcout << L"Node after " << i << L" : " << GetNodeName(ElemPos(position, i)) << '\n';
        std::wcout << L"Elem after " << i << L" : " << GetElemName(ElemPos(position, i), 1) << '\n';
      }
      // size_t argCount = 
		  std::wcout << "FUNC_NAME: " << funcName << '\n';
	  } else if (nodename == L"FUNCDEF") {
		  elemname = GetElemName(position, 1);
		  _asmOutput << L" PUBLIC " << elemname << endl;
		  _asmOutput << elemname << ":" << endl;
		  _asmOutput << L" PUSH EBP" << endl
					 << L" MOV EBP,ESP" << endl
					 << L" SUB ESP," << elemname << L"_len" << endl;
		  Compile(ElemPos(position, 2));
		  Compile(ElemPos(position, 3));
		  _asmOutput << L" MOV ESP,EBP" << endl << L" RET " << endl;
	  } else if (nodename == L"GARRDEF") {
	  } else if (nodename == L"GOTO") {
	  } else if (nodename == L"GREATEREQUTHAN") {
	  } else if (nodename == L"GREATERTHAN") {
	  } else if (nodename == L"GVARDEF") {
	  } else if (nodename == L"IFELSE") {
	  } else if (nodename == L"IF") {
	  } else if (nodename == L"INDEX") {
	  } else if (nodename == L"INIT") {
	  } else if (nodename == L"INT") {
		  _asmOutput << L" MOV EAX," << GetElemName(position, 1) << endl;
	  } else if (nodename == L"ISEQUMOV") {
	  } else if (nodename == L"ISGREATEREQUMOV") {
	  } else if (nodename == L"ISGREATERMOV") {
	  } else if (nodename == L"ISLESSEQUMOV") {
	  } else if (nodename == L"ISLESSMOV") {
	  } else if (nodename == L"ISNEQUMOV") {
	  } else if (nodename == L"LABEL") {
	  } else if (nodename == L"LARRDEF") {
	  } else if (nodename == L"LESSEQUTHAN") {
	  } else if (nodename == L"LESSTHAN") {
	  } else if (nodename == L"LSHIFT") {
	  } else if (nodename == L"LSHIFTMOV") {
	  } else if (nodename == L"LVARDEF") {
		  std::wstring varName = GetElemName(position, 1);
		  std::wcout << L"varName: " << varName << '\n';
	  } else if (nodename == L"MOD") {
	  } else if (nodename == L"MODMOV") {
	  } else if (nodename == L"MOV") {
		  z = ElemPos(position, 1);
		  q = ElemPos(position, 2);
		  if (GetNodeName(z) == L"VAR") {
			  if (GetNodeName(q) == L"INT") {
				  _asmOutput << L" MOV DWORD [" << GetElemName(z, 1) << "],"
							 << GetElemName(q, 1) << endl;
			  } else if (GetNodeName(q) == L"VAR") {
				  _asmOutput << L" MOV EAX, [" << GetElemName(q, 1) << "]" << endl;
				  _asmOutput << L" MOV [" << GetElemName(z, 1) << "],EAX" << endl;
			  } else {
				  Compile(q);
				  _asmOutput << L" MOV [" << GetElemName(z, 1) << "],EAX" << endl;
			  }
		  } else {
			  if (GetNodeName(q) == L"INT") {
				  Compile(z);
				  _asmOutput << L" MOV DWORD [EBX]," << GetElemName(q, 1) << endl;
			  } else if (GetNodeName(q) == L"VAR") {
				  Compile(z);
				  _asmOutput << L" MOV EAX, [" << GetElemName(q, 1) << "]" << endl;
				  _asmOutput << L" MOV [EBX],EAX" << endl;
			  } else {
				  Compile(q);
				  _asmOutput << L" PUSH EAX" << endl;
				  Compile(z);
				  _asmOutput << L" POP EAX" << endl;
				  _asmOutput << L" MOV [EBX],EAX" << endl;
			  }
		  }
	  } else if (nodename == L"MUL") {
	  } else if (nodename == L"MULTMOV") {
	  } else if (nodename == L"NEQU") {
	  } else if (nodename == L"ONUMBER") {
	  } else if (nodename == L"OR") {
	  } else if (nodename == L"ORMOV") {
	  } else if (nodename == L"POSTDEC") {
	  } else if (nodename == L"POSTINC") {
	  } else if (nodename == L"PREDEC") {
	  } else if (nodename == L"PREINC") {
	  } else if (nodename == L"PTR") {
	  } else if (nodename == L"RETURN") {
	  } else if (nodename == L"RETURNPARAM") {
	  } else if (nodename == L"RSHIFT") {
	  } else if (nodename == L"RSHIFTMOV") {
	  } else if (nodename == L"SAMEAS") {
	  } else if (nodename == L"STRING") {
	  } else if (nodename == L"SUB") {
	  } else if (nodename == L"SUBMOV") {
	  } else if (nodename == L"SWITCH") {
	  } else if (nodename == L"UMINUS") {
	  } else if (nodename == L"UNEG") {
	  } else if (nodename == L"UNOT") {
	  } else if (nodename == L"UPLUS") {
	  } else if (nodename == L"VAR") {
		  _asmOutput << L" MOV EAX, [" << GetElemName(position, 1) << "]" << endl;
	  } else if (nodename == L"WHILE") {
	  } else if (nodename == L"XOR") {
	  } else if (nodename == L"XORMOV ") {
	  }
  }




	Parser(Scanner *scanner);
	~Parser();
	void SemErr(const wchar_t* msg);

	void B();
	void Definition();
	void Ident(Name name);
	void GotoLabel(Name name);
	void ConstVal();
	void FunctionDefinition();
	void ArraySize(bool & isarray);
	void Initializator();
	void FunctionHeader();
	void FunctionBody();
	void FormalParamList();
	void Statement();
	void FormalParameter();
	void Label();
	void ExtrnDeclaration();
	void AutoDeclaration();
	void StatementExpression();
	void BreakStatement();
	void CompoundStatement();
	void ContinueStatement();
	void GotoStatement();
	void IfStatement();
	void NullStatement();
	void ReturnStatement();
	void SwitchStatement();
	void WhileStatement();
	void Expression();
	void AssignExpr();
	void CondExpr();
	void OrExpr();
	void XorExpr();
	void AndExpr();
	void EqlExpr();
	void RelExpr();
	void ShiftExpr();
	void AddExpr();
	void MultExpr();
	void UnaryExpr();
	void PostfixExpr();
	void Primary();
	void ArgExprList();

	void Parse();

}; // end Parser



#endif

