/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/


#if !defined(COCO_PARSER_H__)
#define COCO_PARSER_H__

using namespace std;
#include <sstream>
#include "ParseTree.h"
#include "Objects.h"
using namespace bompiler;
#include <wchar.h>
typedef wchar_t Name[500];
#include <string>
#include <iostream>

#include "Scanner.h"

class Errors {
public:
  int count;            // number of errors detected

  Errors();
  void SynErr(int line, int col, int n);
  void Error(int line, int col, const wchar_t *s);
  void Warning(int line, int col, const wchar_t *s);
  void Warning(const wchar_t *s);
  void Exception(const wchar_t *s);

}; // Errors

class Parser {
private:
  enum {
    _EOF = 0,
    _identifier = 1,
    _gotolabel = 2,
    _number = 3,
    _onumber = 4,
    _string = 5,
    _char = 6
  };
  int maxT;

  Token *dummyToken;
  int errDist;
  int minErrDist;

  void SynErr(int n);
  void Get();
  void Expect(int n);
  bool StartOf(int s);
  void ExpectWeak(int n, int follow);
  bool WeakSeparator(int n, int syFol, int repFol);

public:
  Scanner *scanner;
  Errors *errors;
  
  ParseTree pt;
  Objects objs;

  Token *t;            // last recognized token
  Token *la;            // lookahead token

  std::wstring ParseList;
  int scopepos;
  std::wstringstream _asmOutput;
  std::wstringstream _ast;

  int childrenCount(int position);

  std::wstring AST() {
    return _ast.str();
  }

  std::wstring AsmOutput() {
    return _asmOutput.str();
  }

  bool IsDeclaredLocal(Name name1) {
    std::wstring name = std::wstring(name1);
    std::string::size_type found;
    std::wstring decls[4] = {L"EXTRN", L"LARRDEF", L"LVARDEF", L"FPARAM"};
    for (int i = 0; i < 4; i++) {
      found = ParseList.find(L"(" + decls[i] + L" " + name + L" ", scopepos);
      if (found != std::string::npos)
        return true;
    }
    return false;
  }

  bool IsAuto(Name name1) {
    std::wstring name = std::wstring(name1);
    std::string::size_type found;
    std::wstring decls[3] = {L"LARRDEF", L"LVARDEF", L"FPARAM"};
    for (int i = 0; i < 3; i++) {
      found = ParseList.find(L"(" + decls[i] + L" " + name + L" ", scopepos);
      if (found != std::string::npos)
        return true;
    }
    return false;
  }

  bool IsDeclaredGlobal(Name name1) {
    std::wstring name = std::wstring(name1);
    std::string::size_type found;
    std::wstring decls[4] = {L"GARRDEF", L"GVARDEF", L"FUNCDEF"};
    for (int i = 0; i < 4; i++) {
      found = ParseList.find(L"(" + decls[i] + L" " + name + L" ", 0);
      if (found != std::string::npos)
        return true;
    }

    return false;
  }

  void UndecErr(Name name) {
    Name msg;
    wcscpy(msg, L"Undeclared ");
    wcscat(msg, name);
    SemErr(msg);
  }

  void AlreadyErr(Name name) {
    Name msg;
    wcscpy(msg, L"Already declared ");
    wcscat(msg, name);
    SemErr(msg);
  }

  std::wstring GetNodeName(int position) {
    wstring NodeName;
    NodeName = L"";
    if (ParseList[position] != '(')
      return L"";
    position++;
    while (ParseList[position] >= 'A' && ParseList[position] <= 'Z') {
      NodeName += ParseList[position];
      position++;
    }
    return NodeName;
  }

  std::wstring GetElemName(int position, int elemnum) {
    wstring ElemName;
    position = ElemPos(position, elemnum);
    ElemName = L"";
    if (position > 0)
      while (ParseList[position] != ' ' && ParseList[position] != ')') {
        ElemName += ParseList[position];
        position++;
      }
    return ElemName;
  }

  int ElemPos(int position, int elemnum) {
    int currel, brlevel;
    currel = 0;
    position++;
    while (ParseList[position] >= 'A' && ParseList[position] <= 'Z')
      position++;
    for (;;) {
      while (ParseList[position] == ' ')
        position++;
      currel++;
      if (currel == elemnum && ParseList[position] != ')')
        return position;
      switch (ParseList[position]) {
      case '(': brlevel = 1;
        position++;
        while (brlevel != 0) {
          while (ParseList[position] != '(' && ParseList[position] != '`' &&
              ParseList[position] != ')')
            position++;
          switch (ParseList[position]) {
          case '(': brlevel++;
            position++;
            break;
          case ')': brlevel--;
            position++;
            break;
          case '`':
            do {
              position++;
            } while (ParseList[position] != '`');
            position++;
            break;
          }
        }
        break;
      case ')': return -1;
        break;
      case '`':
        do {
          position++;

        } while (ParseList[position] != '`');
        position++;
        break;
      default:
        while (ParseList[position] != '(' && ParseList[position] != ' ' &&
            ParseList[position] != ')')
          position++;
      }
    }
  }

// TODO: L"VAR", L"INDEX" ili L"PTR"
  bool Assignable(int position);
  void Compile(PNode *node);

  Parser(Scanner *scanner);
  ~Parser();
  void SemErr(const wchar_t *msg);

  void B();
  void Definition();
  void Ident(Name name);
  void GotoLabel(Name name);
  void ConstVal();
  void FunctionDefinition();
  void ArraySize(bool &isarray);
  void Initializator();
  void FunctionHeader();
  void FunctionBody();
  void FormalParamList();
  void Statement();
  void FormalParameter();
  void Label();
  void ExtrnDeclaration();
  void AutoDeclaration();
  void StatementExpression();
  void BreakStatement();
  void CompoundStatement();
  void ContinueStatement();
  void GotoStatement();
  void IfStatement();
  void NullStatement();
  void ReturnStatement();
  void SwitchStatement();
  void WhileStatement();
  void Expression();
  void AssignExpr();
  void CondExpr();
  void OrExpr();
  void XorExpr();
  void AndExpr();
  void EqlExpr();
  void RelExpr();
  void ShiftExpr();
  void AddExpr();
  void MultExpr();
  void UnaryExpr();
  void PostfixExpr();
  void Primary();
  void ArgExprList();

  void Parse();

}; // end Parser



#endif

